# Let’s Build A Simple Interpreter. Part 4.

Have you been passively learning the material in these articles 
or have you been actively practicing it? I hope you’ve been actively 
practicing it. I really do :)

Remember what Confucius said?

还记得孔子说过什么吗？

> “I hear and I forget.”

![](../img/LSBAWS_confucius_hear.png)

> “I see and I remember.”

![](../img/LSBAWS_confucius_see.png)

> “I do and I understand.”

![](../img/LSBAWS_confucius_do.png)

> 译者注：以上这段内容其实是荀子说的，“不闻不若闻之，闻之若不见之，见之不若知之，知之不若行之。”

In the previous article you learned how to parse (recognize) 
and interpret arithmetic expressions with any number of plus 
or minus operators in them, for example “7 - 3 + 2 - 1”. 
You also learned about syntax diagrams and how they can be used to specify the syntax of a programming language.

在上一篇文章中，你学会了如何解析（识别）和解释含有任意数量加减运算符的算术表达式，例如 "7 - 3 + 2 - 1"。
你还学习了语法图，以及如何使用它们来指定编程语言的语法。

Today you’re going to learn how to parse and interpret arithmetic 
expressions with any number of multiplication and division operators 
in them, for example “7 * 4 / 2 * 3”. The division in this article 
will be an integer division, so if the expression is “9 / 4”, then the 
answer will be an integer: 2.

今天你将学习如何解析和解释含有任意数量乘法和除法运算符的算术表达式，例如 "7 * 4 / 2 * 3"。
本文中的除法将是整数除法，所以如果表达式是 "9 / 4"，那么答案将是一个整数：2。

I will also talk quite a bit today about another widely used notation 
for specifying the syntax of a programming language. It’s called context-free 
grammars (grammars, for short) or BNF (Backus-Naur Form). For the purpose of 
this article I will not use pure BNF notation but more like a modified EBNF notation.

今天我还会讲不少关于另一种广泛使用的用于指定编程语言语法的符号。
它叫做上下文无关文法（grammars，简称grammars）或BNF（Backus-Naur Form）。
在本文中，我不会使用纯粹的BNF符号，而更像是一种改良的EBNF符号。

Here are a couple of reasons to use grammars:

这里有几个使用语法的理由。

1. A grammar specifies the syntax of a programming language in a concise manner. 
Unlike syntax diagrams, grammars are very compact. 
You will see me using grammars more and more in future articles.

语法以简明的方式规定了编程语言的语法。与句法图不同，语法非常紧凑。
在以后的文章中，你会看到我越来越多地使用语法。

2. A grammar can serve as great documentation.

语法可以起到很好的记录作用。

3. A grammar is a good starting point even if you manually write your parser from scratch. 
Quite often you can just convert the grammar to code by following a set of simple rules.

语法是一个很好的起点，即使你从头开始手动编写你的解析器。
很多时候，你可以按照一套简单的规则将语法转换成代码。

4. There is a set of tools, called parser generators, 
which accept a grammar as an input and automatically 
generate a parser for you based on that grammar. 
I will talk about those tools later on in the series.

有一套工具，叫做解析器生成器。
它接受一个语法作为输入，并根据该语法自动为你生成一个解析器。
我将在后面的系列文章中讲到这些工具。

Now, let’s talk about the mechanical aspects of grammars, shall we?

现在，我们来谈谈语法的机械方面，好吗？

Here is a grammar that describes arithmetic expressions 
like “7 * 4 / 2 * 3” (it’s just one of the many expressions 
that can be generated by the grammar):

这里有一个描述算术表达式的语法，比如 "7 * 4 / 2 * 3"（这只是该语法可以生成的众多表达式之一）。

![](../img/lsbasi_part4_bnf1.png)

A grammar consists of a sequence of rules, also known as productions. 
There are two rules in our grammar:

语法由一连串的规则组成，也就是所谓的产物。在我们的语法中，有两条规则：

![](../img/lsbasi_part4_bnf2.png)

A rule consists of a non-terminal, 
called the head or left-hand side of the production, 
a colon, and a sequence of terminals and/or non-terminals, 
called the body or right-hand side of the production:

一个规则由一个非终结符组成，称为头部或产生式的左侧，一个冒号，以及终结符或非终结符的序列，称为本体或产生式的右侧。

![](../img/lsbasi_part4_bnf3.png)

In the grammar I showed above, 
tokens like MUL, DIV, and INTEGER are called terminals 
and variables like expr and factor are called non-terminals. 
Non-terminals usually consist of a sequence of terminals and/or non-terminals:

在我上面展示的语法中。MUL、DIV、INTEGER 等标记称为终结符，而像 expr 和 factor 这样的变量称为非终结符。
非终结符通常由终结符或非终结符的序列组成。

![](../img/lsbasi_part4_bnf4.png)

The non-terminal symbol on the left side of the first rule is called the start symbol. 
In the case of our grammar, the start symbol is expr:

第一条规则左侧的非终结符被称为其实符号。在我们的语法中，起始符号是expr。

![](../img/lsbasi_part4_bnf5.png)

You can read the rule expr as “An expr can be a factor optionally followed 
by a multiplication or division operator followed by another factor, which 
in turn is optionally followed by a multiplication or division operator 
followed by another factor and so on and so forth.”

你可以将 expr 的规则读为“一个 expr 可以是一个因数，后面可以选择一个乘法或除法运算符，
再后面可以选择一个乘法或除法运算符，再后面可以选择另一个因数，如此等等。”

What is a factor? For the purpose of this article a factor is just an integer.

什么是因数？在本文中，因子只是一个整数。

Let’s quickly go over the symbols used in the grammar and their meaning.

我们快来介绍一下语法中使用的符号及其含义。

* | - Alternatives. A bar means “or”. So (MUL | DIV) means either MUL or DIV.

|--替代物。杠的意思是 "或"。所以(MUL | DIV)表示 MUL 或 DIV。

* ( … ) - An open and closing parentheses mean grouping of terminals and/or non-terminals as in (MUL | DIV).

( … ) - 开括号和闭括号的意思是终结符或非终结符的分组，如（MUL | DIV）。

* ( … )* - Match contents within the group zero or more times.

( … )* - 匹配组内的内容0次或以上。

If you worked with regular expressions in the past, 
then the symbols |, (), and (…)* should be pretty familiar to you.

如果你过去使用过正则表达式，那么符号|、()、(...)*你应该很熟悉。

A grammar defines a language by explaining what sentences it can form. 
This is how you can derive an arithmetic expression using the grammar: 
first you begin with the start symbol expr and then repeatedly replace 
a non-terminal by the body of a rule for that non-terminal until you have 
generated a sentence consisting solely of terminals. Those sentences form 
a language defined by the grammar.

语法通过解释语言可以组成什么句子来定义语言。
这就是如何利用语法推导出一个算术表达式：
首先，我们以起始符号 expr 开始，然后用该非终结符的规则主体反复替换一个非终结符，
直到生成一个完全由终结符组成的句子。这些句子构成了一种由语法定义的语言。

If the grammar cannot derive a certain arithmetic expression, 
then it doesn’t support that expression and the parser will generate a syntax error when it tries to recognize the expression.

如果语法不能导出某个算术表达式，那么它就不支持该表达式，解析器在试图识别该表达式时将产生语法错误。

I think a couple of examples are in order. This is how the grammar derives the expression 3:

我觉得应该举几个例子。语法是这样推导出3这个表达式的。

![](../img/lsbasi_part4_derive1.png)

This is how the grammar derives the expression 3 * 7:

语法就是这样推导出3*7的表达式。

![](../img/lsbasi_part4_derive2.png)

And this is how the grammar derives the expression 3 * 7 / 2:

而语法就是这样推导出3 * 7 / 2的表达式。

![](../img/lsbasi_part4_derive3.png)

Whoa, quite a bit of theory right there!

哇，相当多的理论在那里！

I think when I first read about grammars, 
the related terminology, and all that jazz, 
I felt something like this:

我想，当我第一次读到关于语法，相关的专业术语，以及所有的废话时，我的感觉是这样的。

![](../img/lsbasi_part4_bnf_hmm.png)

I can assure you that I definitely was not like this:

我可以向你保证，我绝对不是这样的人。

![](../img/lsbasi_part4_bnf_yes.png)

It took me some time to get comfortable with the notation, 
how it works, and its relationship with parsers and lexers, 
but I have to tell you that it pays to learn it in the long run 
because it’s so widely used in practice and compiler literature 
that you’re bound to run into it at some point. 
So, why not sooner rather than later? :)

我花了一些时间来适应这个符号，它是如何工作的，以及它与解析器和词典的关系，
但我必须告诉你，从长远来看，学习它是有好处的，因为它在实践和编译器文献中的应用非常广泛，
你一定会在某些时候遇到它。所以，为什么不早点学呢：)

Now, let’s map that grammar to code, okay?

现在，让我们把语法映射成代码，好吗？

Here are the guidelines that we will use to convert the grammar to source code. 
By following them, you can literally translate the grammar to a working parser:

以下是我们将用来将语法转换为源代码的准则。
按照他们的要求，你可以把语法翻译成一个工作的解析器。

1. Each rule, R, defined in the grammar, 
becomes a method with the same name, 
and references to that rule become a method call: R(). 
The body of the method follows the flow of the body of 
the rule using the very same guidelines.

语法中定义的每一条规则 R，都会成为一个同名的方法，
对该规则的引用也会成为一个方法调用。R(). 方法的主体遵循规则主体的流程，使用相同的准则。

2. Alternatives (a1 | a2 | aN) become an if-elif-else statement

替代方案(a1 | a2 | aN)成为if-elif-else语句。

3. An optional grouping (…)* becomes a while statement that can loop over zero or more times

一个可选的分组(...)*成为一个while语句，可以循环 0 次或更多次。

4. Each token reference T becomes a call to the method eat: eat(T). 
The way the eat method works is that it consumes the token T if it 
matches the current lookahead token, then it gets a new token from 
the lexer and assigns that token to the current_token internal variable.

每一个 token 引用 T 都成为对方法 eat：eat(T) 的调用。 eat 方法的工作方式是，
如果 token T 与前后的 token 相匹配，它就会消耗 token，然后从 lexer 中获取一个新的 token，
并将该 token 赋值给 current_token 内部变量。

Visually the guidelines look like this:

从外观上看，指南是这样的。

![](../img/lsbasi_part4_rules.png)

Let’s get moving and convert our grammar to code following the above guidelines.

让我们开始行动起来，按照上面的准则将我们的语法转换为代码。

There are two rules in our grammar: one expr rule and one factor rule. 
Let’s start with the factor rule (production). According to the guidelines, 
you need to create a method called factor (guideline 1) that has a single 
call to the eat method to consume the INTEGER token (guideline 4):

在我们的语法中，有两个规则：一个是 expr 规则，一个是 factor 规则。
先开始说因子的规则吧，（产生式）。按照规则：
你需要创建一个名为factor的方法(准则1)，该方法有一个对eat方法的单次调用，
以消耗 INTEGER token(准则4)。

```python
def factor(self):
    self.eat(INTEGER)
```

That was easy, wasn’t it?

这很容易，不是吗？

Onward!

继续前进！

The rule expr becomes the expr method (again according to the guideline 1). 
The body of the rule starts with a reference to factor that becomes a factor() method call. 
The optional grouping (…)* becomes a while loop and (MUL | DIV) alternatives become an if-elif-else statement. 
By combining those pieces together we get the following expr method:

规则expr变成了expr方法（同样根据准则1）。规则的主体以对 factor 的引用开始，成为factor()方法的调用。
可选的分组(...)*变成了while循环，(MUL | DIV)选项变成了if-elif-else语句。
将这些片段组合在一起，我们得到了下面的expr方法。

```python
def expr(self):
    self.factor()

    while self.current_token.type in (MUL, DIV):
        token = self.current_token
        if token.type == MUL:
            self.eat(MUL)
            self.factor()
        elif token.type == DIV:
            self.eat(DIV)
            self.factor()
```

Please spend some time and study how I mapped the grammar to the source code. 
Make sure you understand that part because it’ll come in handy later on.

请花点时间，研究一下我是如何将语法映射到源代码的。确保你理解这部分内容，因为以后会很方便。

For your convenience I put the above code into the parser.py file that contains a 
lexer and a parser without an interpreter. You can download the file directly from 
GitHub and play with it. It has an interactive prompt where you can enter expressions 
and see if they are valid: that is, if the parser built according to the grammar can 
recognize the expressions.

为了你的方便，我把上面的代码放到了 parser.py 文件中，
这个文件包含了一个词法器和一个没有解释器的解析器。
你可以直接从GitHub上下载这个文件，然后玩一玩。它有一个交互式的提示，
你可以输入表达式，并查看它们是否有效：也就是说，根据语法构建的解析器是否能识别表达式。

Here is a sample session that I ran on my computer:

下面是我在电脑上运行的一个示例会话。

```python
$ python parser.py
calc> 3
calc> 3 * 7
calc> 3 * 7 / 2
calc> 3 *
Traceback (most recent call last):
  File "parser.py", line 155, in <module>
    main()
  File "parser.py", line 151, in main
    parser.parse()
  File "parser.py", line 136, in parse
    self.expr()
  File "parser.py", line 130, in expr
    self.factor()
  File "parser.py", line 114, in factor
    self.eat(INTEGER)
  File "parser.py", line 107, in eat
    self.error()
  File "parser.py", line 97, in error
    raise Exception('Invalid syntax')
Exception: Invalid syntax
```

Try it out!

试试吧！

I couldn’t help but mention syntax diagrams again. This is how a syntax diagram for the same expr rule will look:

我忍不住又提到了语法图。同样的expr规则的语法图是这样的。

![](../img/lsbasi_part4_sd.png)

It’s about time we dug into the source code of our new arithmetic expression interpreter. 
Below is the code of a calculator that can handle valid arithmetic expressions containing 
integers and any number of multiplication and division (integer division) operators. 
You can also see that I refactored the lexical analyzer into a separate class Lexer and 
updated the Interpreter class to take the Lexer instance as a parameter:

我们是时候挖出我们新的算术表达式解释器的源代码了。
下面是一个计算器的代码，它可以处理包含整数和任意数量的乘法和除法（整数除法）运算符的有效算术表达式。
你还可以看到，我将词法分析器重构为一个独立的类Lexer，并更新了解释器类，以Lexer实例为参数。

```python
# Token types
#
# EOF (end-of-file) token is used to indicate that
# there is no more input left for lexical analysis
INTEGER, MUL, DIV, EOF = 'INTEGER', 'MUL', 'DIV', 'EOF'


class Token(object):
    def __init__(self, type, value):
        # token type: INTEGER, MUL, DIV, or EOF
        self.type = type
        # token value: non-negative integer value, '*', '/', or None
        self.value = value

    def __str__(self):
        """String representation of the class instance.

        Examples:
            Token(INTEGER, 3)
            Token(MUL, '*')
        """
        return 'Token({type}, {value})'.format(
            type=self.type,
            value=repr(self.value)
        )

    def __repr__(self):
        return self.__str__()


class Lexer(object):
    def __init__(self, text):
        # client string input, e.g. "3 * 5", "12 / 3 * 4", etc
        self.text = text
        # self.pos is an index into self.text
        self.pos = 0
        self.current_char = self.text[self.pos]

    def error(self):
        raise Exception('Invalid character')

    def advance(self):
        """Advance the `pos` pointer and set the `current_char` variable."""
        self.pos += 1
        if self.pos > len(self.text) - 1:
            self.current_char = None  # Indicates end of input
        else:
            self.current_char = self.text[self.pos]

    def skip_whitespace(self):
        while self.current_char is not None and self.current_char.isspace():
            self.advance()

    def integer(self):
        """Return a (multidigit) integer consumed from the input."""
        result = ''
        while self.current_char is not None and self.current_char.isdigit():
            result += self.current_char
            self.advance()
        return int(result)

    def get_next_token(self):
        """Lexical analyzer (also known as scanner or tokenizer)

        This method is responsible for breaking a sentence
        apart into tokens. One token at a time.
        """
        while self.current_char is not None:

            if self.current_char.isspace():
                self.skip_whitespace()
                continue

            if self.current_char.isdigit():
                return Token(INTEGER, self.integer())

            if self.current_char == '*':
                self.advance()
                return Token(MUL, '*')

            if self.current_char == '/':
                self.advance()
                return Token(DIV, '/')

            self.error()

        return Token(EOF, None)


class Interpreter(object):
    def __init__(self, lexer):
        self.lexer = lexer
        # set current token to the first token taken from the input
        self.current_token = self.lexer.get_next_token()

    def error(self):
        raise Exception('Invalid syntax')

    def eat(self, token_type):
        # compare the current token type with the passed token
        # type and if they match then "eat" the current token
        # and assign the next token to the self.current_token,
        # otherwise raise an exception.
        if self.current_token.type == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            self.error()

    def factor(self):
        """Return an INTEGER token value.

        factor : INTEGER
        """
        token = self.current_token
        self.eat(INTEGER)
        return token.value

    def expr(self):
        """Arithmetic expression parser / interpreter.

        expr   : factor ((MUL | DIV) factor)*
        factor : INTEGER
        """
        result = self.factor()

        while self.current_token.type in (MUL, DIV):
            token = self.current_token
            if token.type == MUL:
                self.eat(MUL)
                result = result * self.factor()
            elif token.type == DIV:
                self.eat(DIV)
                result = result / self.factor()

        return result


def main():
    while True:
        try:
            # To run under Python3 replace 'raw_input' call
            # with 'input'
            text = raw_input('calc> ')
        except EOFError:
            break
        if not text:
            continue
        lexer = Lexer(text)
        interpreter = Interpreter(lexer)
        result = interpreter.expr()
        print(result)


if __name__ == '__main__':
    main()
```

Save the above code into the calc4.py file or download it directly from GitHub. As usual, try it out and see for yourself that it works.

将上面的代码保存到calc4.py文件中，或者直接从GitHub下载。和往常一样，试一试，自己看看能不能用。

This is a sample session that I ran on my laptop:

这是我在我的笔记本电脑上运行的一个示例会话。

```python
$ python calc4.py
calc> 7 * 4 / 2
14
calc> 7 * 4 / 2 * 3
42
calc> 10 * 4  * 2 * 3 / 8
30
```

I know you couldn’t wait for this part :) Here are new exercises for today:

我知道你已经迫不及待地想知道这部分：) 下面是今天的新练习。

![](../img/lsbasi_part4_exercises.png)

* Write a grammar that describes arithmetic expressions containing any number of +, -, *, or / operators. With the grammar you should be able to derive expressions like “2 + 7 * 4”, “7 - 8 / 4”, “14 + 2 * 3 - 6 / 2”, and so on.

写一个语法来描述包含任意数量的+、-、*或/运算符的算术表达式。
有了这个语法，你应该能够推导出 "2 + 7 * 4"、"7 - 8 / 4"、"14 + 2 * 3 - 6 / 2 "等表达式。

* Using the grammar, write an interpreter that can evaluate arithmetic expressions containing any number of +, -, *, or / operators. Your interpreter should be able to handle expressions like “2 + 7 * 4”, “7 - 8 / 4”, “14 + 2 * 3 - 6 / 2”, and so on.

使用该语法，编写一个解释器，它可以评估包含任意数量的+、-、*或/运算符的算术表达式。
你的解释器应该能够处理 "2 + 7 * 4"、"7 - 8 / 4"、"14 + 2 * 3 - 6 / 2 "等表达式。

* If you’ve finished the above exercises, relax and enjoy :)

如果你已经完成了上述练习，请放松并享受:)

Check your understanding.

检查你的理解。

Keeping in mind the grammar from today’s article, answer the following questions, referring to the picture below as needed:

牢记今天文章中的语法，根据需要参考下图，回答下列问题。

![](../img/lsbasi_part4_bnf1.png)

1. What is a context-free grammar (grammar)?

什么是上下文无关文法（grammar）？

2. How many rules / productions does the grammar have?

语法有多少规则/产生式？

3. What is a terminal? (Identify all terminals in the picture)

什么是终结符？(找出图中所有的终结符)

4. What is a non-terminal? (Identify all non-terminals in the picture)

什么是非终结符？(找出图中所有的非终结符)

5. What is a head of a rule? (Identify all heads / left-hand sides in the picture)

什么是规则的头部？(找出图中所有的头部/左手边)

6. What is a body of the rule? (Identify all bodies / right-hand sides in the picture)

什么是规则的主体？(找出图中所有的主体/右侧)

7. What is the start symbol of a grammar?

语法的起始符号是什么？

Hey, you read all the way to the end! This post contained quite a bit of theory, so I’m really proud of you that you finished it.

嘿，你都读到最后了! 这篇文章包含了不少理论，所以我真的很为你感到骄傲，你完成了它。

I’ll be back next time with a new article - stay tuned and don’t forget to do the exercises, they will do you good.

下一次我会带着新的文章回来--敬请期待，别忘了做练习，它们会对你有好处。

Here is a list of books I recommend that will help you in your study of interpreters and compilers:

下面是我推荐的书单，对你学习解释器和编译器会有所帮助。

1. [Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)](https://www.amazon.com/gp/product/193435645X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=193435645X&linkCode=as2&tag=russblo0b-20&linkId=MP4DCXDV6DJMEJBL)
2. [Writing Compilers and Interpreters: A Software Engineering Approach](https://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0470177071&linkCode=as2&tag=russblo0b-20&linkId=UCLGQTPIYSWYKRRM)
3. [Modern Compiler Implementation in Java](https://www.amazon.com/gp/product/052182060X/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=052182060X&linkCode=as2&tag=russblo0b-20&linkId=ZSKKZMV7YWR22NMW)
4. [Modern Compiler Design](https://www.amazon.com/gp/product/1461446988/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1461446988&linkCode=as2&tag=russblo0b-20&linkId=PAXWJP5WCPZ7RKRD)
5. [Compilers: Principles, Techniques, and Tools (2nd Edition)](https://www.amazon.com/gp/product/0321486811/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321486811&linkCode=as2&tag=russblo0b-20&linkId=GOEGDQG4HIHU56FQ)
